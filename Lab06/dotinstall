#!/usr/bin/env bash

# Global variables
alias_file=".bash_aliases"
alias_path="$PWD/$alias_file"
sym_path="$HOME/$alias_file"

# Output command usage
printHelp() {
	echo "Usage: dotinstall [-OPTION] [ARG]"
  	echo "  -s setup - attempts to create a symbolic link .bash_aliases file to user's home directory"
  	echo "  -d disconnect - removes symbolic link"
  	echo "  -a append - adds a new alias to .bash_aliases file"
  	echo "  -r remove - removes an alias from .bash_aliases file"
}

# Output .bashrc source prompt
reloadPrompt() {
	printf "User should reload the shell with %s'source ~/.bashrc'\n" "$1"
}

# Validate 'yes' or 'no' user input
promptYesNo () {
	read -p "Input (Y/N): " choice
	while [[ ! $choice =~ [yYnN] ]]; do
		printf -v error "Invalid option!"
		read -p "$error Input (Y/N): " choice
	done

	echo "$choice"
}

# Establish .bash_aliases symbolic link in user home
formSymlink() {
	(ln -s $alias_path "$sym_path")
	echo "Created symlink $sym_path"
}

# Create .bash_aliases symbolic link in user home
createSymlink () {
	# If .bash_aliases exists in home directory
	if [[ -e "$sym_path" ]]; then

		# Prompt for overwrite
		printf "%s" "$alias_file already exists! Overwrite? "
		if [[ "$(promptYesNo)" =~ [yY] ]]; then
			breakSymlink 	# Remove old link
			formSymlink		# Form new link
			reloadPrompt
		fi
	else
		formSymlink
		reloadPrompt
	fi
}

# Remove .bash_aliases symbolic link from user home
breakSymlink() {
	# Force delete to avoid error output
	(rm -f "$sym_path")
	echo "Removed symlink $sym_path"
}

# Validate whether an alias declaration string is valid
# 	param $1: the string to evaluate
# 	returns: the input string if valid, empty string otherwise
validateAlias () {
	local string=""
	if [[ $1 =~ ^alias[[:space:]]+[[:alnum:]]+\=\".+\"$ ]]; then
		string="$1"
	fi

	echo "$string" # Return empty string if invalid
}

# Extract the raw alias name given an alias declaration string
# 	param $1: the full alias declaration string
# 	returns: the raw alias name, empty string otherwise
extractAliasName () {
	(echo "$1" | grep -Po '(?<=alias )\w+')
}

# Check whether an alias with a name exists in .bash_aliases
# 	param $1: the alias name
# 	returns: the full alias declaration string if it exists, empty string otherwise
findFileAlias () {
	(grep "alias $1=" "$alias_path")
}

# Add an alias to .bash_aliases given an alias declaration string
# 	param $1: the full alias declaration string
addAlias () {

	local string="$(validateAlias "$1")"

	# Consider addition of alias if valid alias declaration string
	if [[ -n $string ]]; then
	
		local name="$(extractAliasName "$string")"
		local from_file="$(findFileAlias "$name")"

		# Add to .bash_aliases if not already present
		if [[ -z $from_file ]]; then
			(echo "$string" >> "$alias_path")
			echo "Alias \"$name\" added to $alias_file!"
			reloadPrompt
		else
			echo "Alias \"$name\" is already in $alias_file!"
		fi
	else
		echo 'Invalid alias declaration of form "alias [name]="[command]"'
	fi
}

# Remove alias given an alias name from .bash_aliases
# 	param $1: the name of the alias to remove
removeAlias() {
	local from_file="$(findFileAlias "$1")"

	# Remove alias from .bash_aliases if present
	if [[ -n $from_file ]]; then
		(sed -i -E "/alias $1=/d" "$alias_path")
		echo "Alias \"$1\" removed from $alias_file!"
		reloadPrompt "'unalias -a' then "
	else
		echo "Alias \"$1\" not found in $alias_file!"
	fi
}

# Assume no arguments before getopts
no_args="true"

# Evaluate options
while getopts ":sda:r:" opt; do
	case $opt in
		s) createSymlink;;
		d) breakSymlink;;
		a) addAlias "$OPTARG";;
		r) removeAlias "$OPTARG";;
		:) echo "An argument must follow option -$OPTARG"; printHelp;;
		\?) echo "Option not supported!"; printHelp;;
	esac
	no_args="false"
done

# Output error message and command usage if no args passed
if [[ "$no_args" == "true" ]]; then
	echo "No options specified!"
	printHelp
fi
