## Lab 03

- Name: Joseph Smith
- Email: smith.3289@wright.edu

## Part 1 - git Guide

| git command         | Description |
| ---                 | ---         | 
| `git clone repo_URI`|     Clones an existing github repository as a directory within the current directory, automatically initializing a remote `origin` branch to `main`.       |
| `git status`        |     Outputs to the console files with unstaged changes in red and files with staged changes in green.       |
| `git add filename`  |     Adds `filename` to the staging area, i.e., prepares the file to be committed.        |
| `git commit`        |     Opens globally configurated text editor to create a commit message. When editor is closed, commits(saves) all files in the staging area to commit history.        |
| `git push`          |     Syncs the local branch and all its commits to the default remote branch on github. In our case, `origin`(remote) `main`(branch).        |
| `git pull`          |     Syncs the default remote branch to the local branch. If the commit history doesn't match, we might have to address merge conflicts and create a merge commit. |

## Part 2 - clone

1. Command to generate an SSH key with ed25519:
    ```bash
    ssh-keygen -t ed25519 -C "josmth3030@gmail.com"
    ```
2. Command(s) to read & copy text of the *public* key:
    ```bash
    cat ~/.ssh/id_ed25519.pub #or, install xclip with sudo apt install xclip
    xclip -selection clipboard ~/.ssh/id_ed25519.pub # copies the contents of the key file to the clipboard
    ```
3. Summary of steps to place *public* key in user profile:
    <ol>
        <li>Copy contents of public key file in terminal using <code>cat ~/.ssh/id_ed25519.pub</code> or <code>xclip -selection clipboard ~/.ssh/id_ed25519</code></li>
        <li>Open github.com and click profile icon in top right, click <code>Settings</code></li>
        <li>Click <code>SSH and GPG keys</code> in side menu</li>
        <li>Click <code>New SSH key</code> button</li>
        <li>Give the key a title and paste to copied key to the <code>Key</code> input box</li>
        <li>Click <code>Add SSH key</code> button</li>
        <li>You can now push to and pull from your github repositories!</li>
    </ol>

4. Command to *clone* your `ceg2350s25-YOURGITHUBUSERNAME` with SSH for authentication: 
    ```bash
    git clone git@github.com:WSU-kduncan/ceg2350f25-joeesmithh.git
    ```

## Part 3 - IO Redirection

1. `printenv HOME > thishouse`
   - Explanation:

        Generates standard output text stream containing the value of the `HOME` environment variable (path to the current user's home directory) and redirects it to the `thishouse` file. Overwrites any existing text, but creates the file if it doesn't already exist. The `thishouse` file now contains the text "/home/ubuntu."
2. `cat doesnotexist 2>> hush.txt`
   - Explanation: 
    1. **First case**: Redirects and appends generated standard error text stream to `hush.txt` file if `doesnotexist` file does not exist, also creating `hush.txt` if it does not exists. In this case, `hush.txt` contains "cat: doesnotexist: No such file or directory."
    2. **Second case**: Outputs to the console generated standard output text stream containing the contents of `doesnotexist` if the file exists. Creates `hush.txt` file if it does not exist. `hush.txt` contains nothing.
3. `cat nums.txt | sort -n >> all_nums.txt`
   - Explanation: Takes the standard output of `cat nums.txt` (if the file exists) and uses it as input to the `sort` command with the `-n` flag (which sorts each line of its input by string numerical value) and appends the result of the sort in `all_nums.txt`.
4. `cat << "DONE" > here.txt`
   - Explanation: Redirects and appends standard input generated from the user (via entering text from the keyboard and pressing [ENTER]) into the `cat` command until the delimeter "DONE" is entered. The standard output generated by `cat` is then redirected to the `here.txt` file, creating the file if it doesn't exists, and overwriting any existing data.
5. `ls -lt ~ | head`
   - Explanation: Takes the standard output generated by `ls -lt ~` (which lists the contents of the current user's home directory in long listing format by most recent date of modification) and uses as input to the `head` command, effectively outputting to the console the first 10 most recently modified files in the user's home directory.
6. `history | grep ".md"`
   - Explanation: Generates standard output containing the user's command history with `history` and uses as input into the `grep` command with the `".md"` pattern. `grep` generates its own standard output to the console containing each line of `history` which contained the ".md" pattern, with the pattern highlighted red.

## Part 4 - Rolling the Dice

Verify that `roll` made it to your GitHub repository for this course and is in your `Lab03` folder.  No answers will be written here unless you would like to leave a note to the TAs

## Part 5 - Retrospective Answers

1. Where and when did it go wrong while working on your script tasks?
    > There was a portion of the development where I couldn't get the input validation working in the way I wanted to, but eventually regular expressions came to save the day.
2. Was anything familiar working with a new language compared to one you are used to?
    > Writing in bash reminded me a lot of writing AutoHotkey scripts, which is also very ambiguous when it comes to variable declarations.
3. Did you write good `commit` messages that refer to what tasks were completed at each commit?  What would you improve?
    > I tried to write commit messages following every major feature implementation, though I'm not very good at remembering to write detailed descriptions under the main commit messages.

## Extra Credit

1. One extra feature I added was handling the case where one argument was given by assigning the argument to the number of dice, but still prompting the user for the number of dice sides. I also handled the case where too many arguments were given by using the first two arguments as the number of dice and sides.

## Citations

[Bash Regex: How to Use Regex in a Shell Script](https://kodekloud.com/blog/regex-shell-script/): Contributed to understanding of how to use regular expressions to validate strings within if statements.
